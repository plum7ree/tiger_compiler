package org.lulz.tiger.backend.codegen;

import org.lulz.tiger.common.ir.IRFunction;
import org.lulz.tiger.common.ir.IRInsn;
import org.lulz.tiger.common.ir.IRListing;
import org.lulz.tiger.common.ir.Opcode;
import org.lulz.tiger.common.symbol.Symbol;
import org.lulz.tiger.common.symbol.SymbolClass;
import org.lulz.tiger.common.type.ArrayType;
import org.lulz.tiger.common.type.FunctionType;
import org.lulz.tiger.common.type.TypeKind;

import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.Callable;

import static org.lulz.tiger.backend.codegen.MIPSRegister.*;
import static org.lulz.tiger.common.ir.Opcode.*;

public class MIPSCodeGenerator implements Callable<String> {
    private IRListing irListing;
    private StringBuilder buffer = new StringBuilder();
    private RegisterAllocator provider;

    private static MIPSRegister RESERVED_A = t8;
    private static MIPSRegister RESERVED_B = t9;
    public static MIPSRegister[] ARG_REGS = {a0, a1, a2, a3};
    public static MIPSRegister[] GP_REGS = {t0, t1, t2, t3, t4, t5, t6, t7, s0, s1, s2, s3, s4, s5, s6, s7};

    public MIPSCodeGenerator(IRListing irListing, RegisterAllocator provider) {
        this.irListing = irListing;
        this.provider = provider;
    }

    private void lowerFunction(IRFunction function) {
        // label
        emit(function.getName() + ":");

        // prologue
        emit("sub", sp, sp, "" + (function.getFrameSize() + 4));
        if ("main".equals(function.getName())) {
            emit("move", gp, sp);    // initialize global pointer
        }
        emit("sw", ra, "" + function.getFrameSize() + "(" + sp + ")");

        function.getInstructions().forEach(this::lowerInstruction);

        // epilogue(s) are generated by return
    }

    private void lowerInstruction(IRInsn insn) {
        if (insn.isLabel()) {
            emit(insn.toString());
            return;
        }

        switch (insn.getOpcode()) {
            case ASSIGN:
                MIPSRegister target = getRegister(insn.getOperands()[0], insn, RESERVED_A, false, false);
                MIPSRegister val = getRegister(insn.getOperands()[1], insn, RESERVED_B, true, false);
                if (target != val) {
                    emit("move", target, val);
                }
                if (insn.getOperands()[0].getType().getKind() == TypeKind.FLOAT
                        && insn.getOperands()[1].getType().getKind() == TypeKind.INT) { // float widening
                    int2float(target);
                }
                saveIfSpilled(insn.getOperands()[0], insn, target);
                break;
            case ADD:
            case SUB:
            case MUL:
            case DIV:
            case AND:
            case OR:
                MIPSRegister store = getRegister(insn.getOperands()[0], insn, RESERVED_A, false, false);
                MIPSRegister op1 = getRegister(insn.getOperands()[1], insn, RESERVED_A, true, false);
                MIPSRegister op2 = getRegister(insn.getOperands()[2], insn, RESERVED_B, true, false);
                if (insn.getOperands()[1].getType().getKind() == TypeKind.FLOAT
                        || insn.getOperands()[2].getType().getKind() == TypeKind.FLOAT) { // float operation
                    emit("mtc1", op1, f0);
                    emit("mtc1", op2, f1);
                    if (insn.getOperands()[1].getType().getKind() == TypeKind.INT) {    // widen
                        emit("cvt.s.w", f0, f0);
                    }
                    if (insn.getOperands()[2].getType().getKind() == TypeKind.INT) {    // widen
                        emit("cvt.s.w", f1, f1);
                    }
                    emit(insn.getOpcode().name().toLowerCase() + ".s", f0, f0, f1);
                    emit("mfc1", store, f0);    // move back to int regs
                } else {    // int operation
                    emit(insn.getOpcode().name().toLowerCase(), store, op1, op2);
                    if (insn.getOperands()[0].getType().getKind() == TypeKind.FLOAT) { // widen to float
                        int2float(store);
                    }
                }
                saveIfSpilled(insn.getOperands()[0], insn, store);
                break;
            case GOTO:
                emit("j", insn.getOperands()[0].getName());
                break;
            case BEQ:
            case BNE:
            case BLT:
            case BGT:
            case BGE:
            case BLE:
                MIPSRegister cmp1 = getRegister(insn.getOperands()[0], insn, RESERVED_A, true, false);
                MIPSRegister cmp2 = getRegister(insn.getOperands()[1], insn, RESERVED_B, true, false);
                if (insn.getOperands()[0].getType().getKind() == TypeKind.FLOAT ||
                        insn.getOperands()[1].getType().getKind() == TypeKind.FLOAT) { // float compare
                    emit("mtc1", cmp1, f0);
                    emit("mtc1", cmp2, f1);
                    if (insn.getOperands()[0].getType().getKind() == TypeKind.INT) {    // widen
                        emit("cvt.s.w", f0, f0);
                    }
                    if (insn.getOperands()[1].getType().getKind() == TypeKind.INT) {    // widen
                        emit("cvt.s.w", f1, f1);
                    }
                    emit(getFloatCompareInstruction(insn.getOpcode()), f0, f1);
                    if (insn.getOpcode() == BEQ || insn.getOpcode() == BLT || insn.getOpcode() == BLE) {
                        emit("bc1t", insn.getOperands()[2].getName());
                    } else {
                        emit("bc1f", insn.getOperands()[2].getName());
                    }
                } else {
                    emit(insn.getOpcode().name().toLowerCase(), cmp1, cmp2, insn.getOperands()[2].getName());
                }
                break;
            case RETURN:
                getRegister(insn.getOperands()[0], insn, v0, true, true);
                if (((FunctionType) insn.getFunction().getSymbol().getType()).getRetVal().getKind() == TypeKind.FLOAT &&
                        insn.getOperands()[0].getType().getKind() == TypeKind.INT) { // float widening
                    int2float(v0);
                }
                emit("lw", ra, "" + insn.getFunction().getFrameSize() + "(" + sp + ")");
                emit("add", sp, sp, "" + (insn.getFunction().getFrameSize() + 4));
                emit("jr", ra);
                break;
            case CALL:
                // save live variables in inSet of call
                insn.getInSet().forEach(s -> save(s, insn));

                // prepare arguments
                for (int i = 0; i < insn.getOperands().length - 2; i++) {
                    getRegister(insn.getOperands()[i + 2], insn, ARG_REGS[i], true, true);
                    // widen arg if necessary
                    if (insn.getOperands()[i + 2].getType().getKind() == TypeKind.INT &&
                            ((FunctionType) insn.getOperands()[1].getType()).getArgs()[i].getKind() == TypeKind.FLOAT) {
                        int2float(ARG_REGS[i]);
                    }
                }

                emit("jal", insn.getOperands()[1].getName());

                // restore live variables needed in outSet of call
                insn.getOutSet().stream()
                        .filter(s -> s != insn.getOperands()[0])
                        .forEach(s -> restore(s, insn));

                // widen retval if necessary
                if (insn.getOperands()[0].getType().getKind() == TypeKind.INT &&
                        ((FunctionType) insn.getOperands()[1].getType()).getRetVal().getKind() == TypeKind.FLOAT) {
                    int2float(v0);
                }

                // copy return value
                saveIfSpilled(insn.getOperands()[0], insn, v0);
                break;
            case STORE:
            case LOAD:
                boolean isStore = insn.getOpcode() == Opcode.STORE;
                MIPSRegister x = getRegister(insn.getOperands()[0], insn, RESERVED_A, isStore, false);
                MIPSRegister off = getRegister(insn.getOperands()[2], insn, RESERVED_B, true, true);
                MIPSRegister base = sp;
                if (insn.getOperands()[1].getFunction() != insn.getFunction().getSymbol()) { // global var access
                    base = gp;
                }
                emit("sll", off, off, "2"); // multiply by 4
                emit("add", off, off, base);
                if (isStore) {
                    if (((ArrayType) insn.getOperands()[1].getType()).getElementType().getKind() == TypeKind.FLOAT &&
                            insn.getOperands()[0].getType().getKind() == TypeKind.INT) {
                        emit("move", RESERVED_A, x);
                        int2float(RESERVED_A);
                        x = RESERVED_A;
                    }
                    emit("sw", x, "" + insn.getOperands()[1].getFrameIndex() + "(" + off + ")");
                } else {
                    emit("lw", x, "" + insn.getOperands()[1].getFrameIndex() + "(" + off + ")");
                    if (((ArrayType) insn.getOperands()[1].getType()).getElementType().getKind() == TypeKind.INT &&
                            insn.getOperands()[0].getType().getKind() == TypeKind.FLOAT) {
                        int2float(x);
                    }
                    saveIfSpilled(insn.getOperands()[0], insn, x);
                }
                break;
            case ARRINIT:
                MIPSRegister base_ = sp;
                if (insn.getOperands()[0].getFunction() != insn.getFunction().getSymbol()) { // global var access
                    base_ = gp;
                }
                emit("la", RESERVED_A, "" + insn.getOperands()[0].getFrameIndex() + "(" + base_ + ")"); // address
                emit("li", RESERVED_B, "" + ((ArrayType) insn.getOperands()[0].getType()).getSize()); // arr size
                getRegister(insn.getOperands()[1], insn, v0, true, true); // value
                if (((ArrayType) insn.getOperands()[0].getType()).getElementType().getKind() == TypeKind.FLOAT &&
                        insn.getOperands()[1].getType().getKind() == TypeKind.INT) { // widen
                    int2float(v0);
                }
                emit("jal", "_memset");
                break;
        }
    }

    private MIPSRegister getRegister(Symbol symbol, IRInsn insn, MIPSRegister fallbackRegister, boolean load, boolean forceReg) {
        if (symbol.isConstant()) {
            String val;
            if (symbol.getSymbolClass() == SymbolClass.ICONST) {
                val = String.valueOf(symbol.getIntVal());
            } else {
                val = "0x" + Integer.toHexString(Float.floatToIntBits(symbol.getFloatVal()));
            }
            emit("li", fallbackRegister, val);
            return fallbackRegister;
        }
        MIPSRegister reg = provider.getRegister(symbol, insn);
        if (reg != null) {
            if (forceReg) {
                emit("move", fallbackRegister, reg);
                return fallbackRegister;
            }
            return reg;
        } else if (load) {
            // spilled var, load it into fallback register
            MIPSRegister base = sp;
            if (symbol.getFunction() != insn.getFunction().getSymbol()) { // global var access
                base = gp;
            }
            emit("lw", fallbackRegister, "" + symbol.getFrameIndex() + "(" + base + ")");
        }
        return fallbackRegister;
    }

    private void saveIfSpilled(Symbol symbol, IRInsn insn, MIPSRegister register) {
        MIPSRegister reg = provider.getRegister(symbol, insn);
        if (reg != null) {
            if (reg != register) {
                emit("move", reg, register);
            }
        } else {
            MIPSRegister base = sp;
            if (symbol.getFunction() != insn.getFunction().getSymbol()) { // global var access
                base = gp;
            }
            emit("sw", register, "" + symbol.getFrameIndex() + "(" + base + ")");
        }
    }

    private void save(Symbol symbol, IRInsn insn) {
        MIPSRegister reg = provider.getRegister(symbol, insn);
        if (reg == null) {
            return;
        }
        MIPSRegister base = sp;
        if (symbol.getFunction() != insn.getFunction().getSymbol()) { // global var access
            base = gp;
        }
        emit("sw", reg, "" + symbol.getFrameIndex() + "(" + base + ")");
    }

    private void restore(Symbol symbol, IRInsn insn) {
        MIPSRegister reg = provider.getRegister(symbol, insn);
        if (reg == null) {
            return;
        }
        MIPSRegister base = sp;
        if (symbol.getFunction() != insn.getFunction().getSymbol()) { // global var access
            base = gp;
        }
        emit("lw", reg, "" + symbol.getFrameIndex() + "(" + base + ")");
    }

    private void int2float(MIPSRegister reg) {
        emit("mtc1", reg, f0);
        emit("cvt.s.w", f0, f0);
        emit("mfc1", reg, f0);
    }

    private String getFloatCompareInstruction(Opcode opcode) {
        switch (opcode) {
            case BEQ:
            case BNE:
                return "c.eq.s";
            case BLT:
            case BGE:
                return "c.lt.s";
            case BLE:
            case BGT:
                return "c.le.s";
            default:
                throw new RuntimeException("bad opcode");
        }
    }

    private void emit(String op, CharSequence... args) {
        buffer.append(op);
        if (args.length != 0) {
            buffer.append(" ").append(String.join(", ", args));
        }
        buffer.append("\n");
    }

    @Override
    public String call() throws IOException {
        try (InputStream input = getClass().getResourceAsStream("/header.asm")) {
            buffer.append(new String(input.readAllBytes()));
        }
        irListing.getFunctions().forEach(this::lowerFunction);
        return buffer.toString();
    }
}
